# Python Overloading: Coding Challenges

These challenges explore Python's approach to overloadingâ€”including operator overloading via special methods and function overloading via `functools.singledispatch` and modern techniques like `@overload` from the `typing` module.

---

## Challenge 1: Basic Operator Overloading

**Objective**: Create a class `Vector2D` that supports the following operations:

* `+` (addition)
* `-` (subtraction)
* `==` (equality)
* `repr()` for human-readable output

```python
v1 = Vector2D(2, 3)
v2 = Vector2D(4, 1)
assert v1 + v2 == Vector2D(6, 4)
```

---

## Challenge 2: Custom Comparison Operators

**Objective**: Implement a `Box` class where comparison is based on volume.

* Implement `__lt__`, `__eq__`
* Use `@total_ordering` to auto-fill the rest

```python
assert Box(2, 2, 2) < Box(3, 3, 3)
assert Box(2, 2, 2) <= Box(2, 2, 2)
```

---

## Challenge 3: Custom Indexing (`__getitem__` and `__setitem__`)

**Objective**: Create a class `SparseList` that mimics list behavior but only stores non-zero items in a dictionary internally.

```python
s = SparseList()
s[100] = 5
assert s[100] == 5
assert s[50] == 0
```

---

## Challenge 4: Function Overloading with `singledispatch`

**Objective**: Create a function `describe(x)` using `functools.singledispatch`:

* For `int`: return "This is an integer."
* For `str`: return "This is a string."
* For `list`: return "This is a list."

```python
assert describe(5) == "This is an integer."
```

---

## Challenge 5: Simulate Method Overloading with Default Arguments

**Objective**: Create a method `greet` that:

* With no arguments returns "Hello, world!"
* With one string returns "Hello, <name>!"

```python
def greet(name=None):
    ...

assert greet() == "Hello, world!"
assert greet("Alice") == "Hello, Alice!"
```

---

## Challenge 6: Use `typing.overload` for Static Type Hints

**Objective**: Create a function `get_config()` that:

* Returns `int` when given `'max_retries'`
* Returns `str` when given `'env'`

Use `@overload` annotations from `typing` to help static checkers.

```python
@overload
def get_config(key: Literal["max_retries"]) -> int: ...

@overload
def get_config(key: Literal["env"]) -> str: ...

def get_config(key):
    if key == "max_retries":
        return 5
    elif key == "env":
        return "production"
```

---

## Challenge 7: Overload Callable Objects

**Objective**: Create a class `Repeater` that supports being called like a function.

```python
r = Repeater("hi")
assert r(3) == "hihihi"
```

---

## Challenge 8: Overloading Arithmetic for a Custom Fraction Class

**Objective**: Implement a class `Fraction` that supports:

* Addition
* Multiplication
* Equality
* Simplification to lowest terms

```python
f1 = Fraction(1, 2)
f2 = Fraction(2, 4)
assert f1 == f2
assert f1 + f1 == Fraction(1, 1)
```

---

## Challenge 9: Reversible Addition (`__radd__`)

**Objective**: Update `Vector2D` from Challenge 1 to support reversed operands.

```python
assert Vector2D(1, 2) + (3, 4) == Vector2D(4, 6)
assert (3, 4) + Vector2D(1, 2) == Vector2D(4, 6)
```

---

## Challenge 10: Subclassing Built-ins with Overloads

**Objective**: Subclass `dict` to create a `CaseInsensitiveDict` that overrides:

* `__getitem__`
* `__setitem__`
* `__contains__`

```python
d = CaseInsensitiveDict()
d['KEY'] = 1
assert d['key'] == 1
assert 'KEY' in d and 'key' in d
```
